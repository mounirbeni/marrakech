{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mouni/Desktop/marrakech/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\r\n\r\nconst prismaClientSingleton = () => {\r\n    return new PrismaClient()\r\n}\r\n\r\ndeclare global {\r\n    var prisma: undefined | ReturnType<typeof prismaClientSingleton>\r\n}\r\n\r\nconst prisma = globalThis.prisma ?? prismaClientSingleton()\r\n\r\nexport default prisma\r\n\r\nif (process.env.NODE_ENV !== 'production') globalThis.prisma = prisma\r\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,wBAAwB;IAC1B,OAAO,IAAI,6IAAY;AAC3B;AAMA,MAAM,SAAS,WAAW,MAAM,IAAI;uCAErB;AAEf,wCAA2C,WAAW,MAAM,GAAG"}},
    {"offset": {"line": 68, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mouni/Desktop/marrakech/src/lib/trip-logic.ts"],"sourcesContent":["import { Booking } from '@prisma/client';\r\n\r\nexport type TripState = 'NO_TRIP' | 'UPCOMING' | 'ONGOING' | 'COMPLETED';\r\n\r\nexport function determineTripState(bookings: Booking[]): TripState {\r\n    if (!bookings || bookings.length === 0) {\r\n        return 'NO_TRIP';\r\n    }\r\n\r\n    const now = new Date();\r\n\r\n    // Sort bookings by date, most recent first\r\n    const sortedBookings = [...bookings].sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());\r\n\r\n    // Find the most relevant booking\r\n    // Logic: \r\n    // 1. Is there a booking happening right now? (Ongoing)\r\n    // 2. Is there a booking in the future? (Upcoming)\r\n    // 3. Was there a booking recently? (Completed)\r\n\r\n    // This is a simplified logic. In reality, a \"Trip\" might define a range of dates containing multiple bookings.\r\n    // For now, we look at individual bookings.\r\n\r\n    const upcomingBookings = sortedBookings.filter(b => new Date(b.date) > now && b.status === 'CONFIRMED');\r\n    const pastBookings = sortedBookings.filter(b => new Date(b.date) <= now && b.status === 'CONFIRMED'); // And not cancelled\r\n\r\n    if (upcomingBookings.length > 0) {\r\n        // Check if the closest upcoming booking is actually \"ongoing\" (e.g. started 1 hour ago but lasts 4 hours)\r\n        // For now, assuming \"Upcoming\" if start date is in future.\r\n\r\n        // But wait, if we have a booking TODAY, it might be ongoing.\r\n        // Let's refine.\r\n\r\n        const nextBooking = upcomingBookings[upcomingBookings.length - 1]; // closest future booking\r\n        const timeDiff = new Date(nextBooking.date).getTime() - now.getTime();\r\n        const hoursDiff = timeDiff / (1000 * 60 * 60);\r\n\r\n        if (hoursDiff < 24 && hoursDiff > -24) {\r\n            // If it's within 24 hours? \r\n            // Actually, \"Ongoing\" usually means the user is physically there.\r\n            // Let's assume distinct states for now.\r\n            return 'UPCOMING';\r\n        }\r\n        return 'UPCOMING';\r\n    }\r\n\r\n    // If no upcoming bookings, check if we have any active/ongoing ones.\r\n    // Since we filtered \"upcoming\" as > now, \"past\" is <= now.\r\n    // If a booking started 1 hour ago, it's in \"pastBookings\" but technically \"Ongoing\" if it has duration.\r\n    // We need duration.\r\n\r\n    // For this MVP logic without duration parsing:\r\n    // If the most recent past booking was within 24 hours, call it \"ONGOING\" or \"COMPLETED\" depending on logic.\r\n    // Let's assume if it started < 12 hours ago, it's ONGOING.\r\n\r\n    if (pastBookings.length > 0) {\r\n        const lastBooking = pastBookings[0];\r\n        const timeSinceStart = now.getTime() - new Date(lastBooking.date).getTime();\r\n        const hoursSinceStart = timeSinceStart / (1000 * 60 * 60);\r\n\r\n        if (hoursSinceStart < 12) {\r\n            return 'ONGOING';\r\n        }\r\n\r\n        return 'COMPLETED';\r\n    }\r\n\r\n    return 'NO_TRIP';\r\n}\r\n"],"names":[],"mappings":";;;;AAIO,SAAS,mBAAmB,QAAmB;IAClD,IAAI,CAAC,YAAY,SAAS,MAAM,KAAK,GAAG;QACpC,OAAO;IACX;IAEA,MAAM,MAAM,IAAI;IAEhB,2CAA2C;IAC3C,MAAM,iBAAiB;WAAI;KAAS,CAAC,IAAI,CAAC,CAAC,GAAG,IAAM,IAAI,KAAK,EAAE,IAAI,EAAE,OAAO,KAAK,IAAI,KAAK,EAAE,IAAI,EAAE,OAAO;IAEzG,iCAAiC;IACjC,UAAU;IACV,uDAAuD;IACvD,kDAAkD;IAClD,+CAA+C;IAE/C,+GAA+G;IAC/G,2CAA2C;IAE3C,MAAM,mBAAmB,eAAe,MAAM,CAAC,CAAA,IAAK,IAAI,KAAK,EAAE,IAAI,IAAI,OAAO,EAAE,MAAM,KAAK;IAC3F,MAAM,eAAe,eAAe,MAAM,CAAC,CAAA,IAAK,IAAI,KAAK,EAAE,IAAI,KAAK,OAAO,EAAE,MAAM,KAAK,cAAc,oBAAoB;IAE1H,IAAI,iBAAiB,MAAM,GAAG,GAAG;QAC7B,0GAA0G;QAC1G,2DAA2D;QAE3D,6DAA6D;QAC7D,gBAAgB;QAEhB,MAAM,cAAc,gBAAgB,CAAC,iBAAiB,MAAM,GAAG,EAAE,EAAE,yBAAyB;QAC5F,MAAM,WAAW,IAAI,KAAK,YAAY,IAAI,EAAE,OAAO,KAAK,IAAI,OAAO;QACnE,MAAM,YAAY,WAAW,CAAC,OAAO,KAAK,EAAE;QAE5C,IAAI,YAAY,MAAM,YAAY,CAAC,IAAI;YACnC,4BAA4B;YAC5B,kEAAkE;YAClE,wCAAwC;YACxC,OAAO;QACX;QACA,OAAO;IACX;IAEA,qEAAqE;IACrE,2DAA2D;IAC3D,wGAAwG;IACxG,oBAAoB;IAEpB,+CAA+C;IAC/C,4GAA4G;IAC5G,2DAA2D;IAE3D,IAAI,aAAa,MAAM,GAAG,GAAG;QACzB,MAAM,cAAc,YAAY,CAAC,EAAE;QACnC,MAAM,iBAAiB,IAAI,OAAO,KAAK,IAAI,KAAK,YAAY,IAAI,EAAE,OAAO;QACzE,MAAM,kBAAkB,iBAAiB,CAAC,OAAO,KAAK,EAAE;QAExD,IAAI,kBAAkB,IAAI;YACtB,OAAO;QACX;QAEA,OAAO;IACX;IAEA,OAAO;AACX"}},
    {"offset": {"line": 128, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mouni/Desktop/marrakech/src/app/api/dashboard/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\r\nimport prisma from '@/lib/prisma';\r\nimport { determineTripState } from '@/lib/trip-logic';\r\n\r\nexport async function GET(request: Request) {\r\n    try {\r\n        // TODO: Get real User ID from session\r\n        // const session = await getServerSession(authOptions);\r\n        // if (!session) return new NextResponse('Unauthorized', { status: 401 });\r\n        // const userId = session.user.id;\r\n\r\n        // For development, we'll try to find a user with bookings, or fall back to a demo user.\r\n        // Ideally, pass ?userId=... query param for testing if not auth.\r\n        const { searchParams } = new URL(request.url);\r\n        const userIdInfo = searchParams.get('userId');\r\n\r\n        let userId = userIdInfo;\r\n\r\n        if (!userId) {\r\n            // Find a user with bookings for demo\r\n            const demoUser = await prisma.user.findFirst({\r\n                where: { bookings: { some: {} } }\r\n            });\r\n            if (demoUser) userId = demoUser.id;\r\n        }\r\n\r\n        if (!userId) {\r\n            return NextResponse.json({\r\n                state: 'NO_TRIP',\r\n                bookings: [],\r\n                message: 'No user found or no bookings.'\r\n            });\r\n        }\r\n\r\n        const bookings = await prisma.booking.findMany({\r\n            where: { userId: userId },\r\n            include: {\r\n                // If relations exist, include them. \r\n                // Based on schema: nothing specific to include for logic, maybe 'review'.\r\n            }\r\n        });\r\n\r\n        const state = determineTripState(bookings);\r\n\r\n        return NextResponse.json({\r\n            state,\r\n            bookings,\r\n            // Recommendations would go here\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error('Dashboard API Error:', error);\r\n        return new NextResponse('Internal Server Error', { status: 500 });\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEO,eAAe,IAAI,OAAgB;IACtC,IAAI;QACA,sCAAsC;QACtC,uDAAuD;QACvD,0EAA0E;QAC1E,kCAAkC;QAElC,wFAAwF;QACxF,iEAAiE;QACjE,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;QAC5C,MAAM,aAAa,aAAa,GAAG,CAAC;QAEpC,IAAI,SAAS;QAEb,IAAI,CAAC,QAAQ;YACT,qCAAqC;YACrC,MAAM,WAAW,MAAM,iIAAM,CAAC,IAAI,CAAC,SAAS,CAAC;gBACzC,OAAO;oBAAE,UAAU;wBAAE,MAAM,CAAC;oBAAE;gBAAE;YACpC;YACA,IAAI,UAAU,SAAS,SAAS,EAAE;QACtC;QAEA,IAAI,CAAC,QAAQ;YACT,OAAO,gJAAY,CAAC,IAAI,CAAC;gBACrB,OAAO;gBACP,UAAU,EAAE;gBACZ,SAAS;YACb;QACJ;QAEA,MAAM,WAAW,MAAM,iIAAM,CAAC,OAAO,CAAC,QAAQ,CAAC;YAC3C,OAAO;gBAAE,QAAQ;YAAO;YACxB,SAAS;YAGT;QACJ;QAEA,MAAM,QAAQ,IAAA,mJAAkB,EAAC;QAEjC,OAAO,gJAAY,CAAC,IAAI,CAAC;YACrB;YACA;QAEJ;IAEJ,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,wBAAwB;QACtC,OAAO,IAAI,gJAAY,CAAC,yBAAyB;YAAE,QAAQ;QAAI;IACnE;AACJ"}}]
}