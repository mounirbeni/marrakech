{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mouni/Desktop/marrakech/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\r\n\r\nconst prismaClientSingleton = () => {\r\n    return new PrismaClient()\r\n}\r\n\r\ndeclare global {\r\n    var prisma: undefined | ReturnType<typeof prismaClientSingleton>\r\n}\r\n\r\nconst prisma = globalThis.prisma ?? prismaClientSingleton()\r\n\r\nexport default prisma\r\n\r\nif (process.env.NODE_ENV !== 'production') globalThis.prisma = prisma\r\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,wBAAwB;IAC1B,OAAO,IAAI,6IAAY;AAC3B;AAMA,MAAM,SAAS,WAAW,MAAM,IAAI;uCAErB;AAEf,wCAA2C,WAAW,MAAM,GAAG"}},
    {"offset": {"line": 68, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mouni/Desktop/marrakech/src/lib/auth.ts"],"sourcesContent":["import { SignJWT, jwtVerify, JWTPayload } from 'jose'\r\nimport { cookies } from 'next/headers'\r\n\r\nconst secretKey = process.env.JWT_SECRET_KEY || 'your-secret-key-change-this-in-prod'\r\nconst key = new TextEncoder().encode(secretKey)\r\n\r\nexport async function encrypt(payload: JWTPayload) {\r\n    return await new SignJWT(payload)\r\n        .setProtectedHeader({ alg: 'HS256' })\r\n        .setIssuedAt()\r\n        .setExpirationTime('24h')\r\n        .sign(key)\r\n}\r\n\r\nexport async function decrypt(input: string): Promise<JWTPayload | null> {\r\n    try {\r\n        const { payload } = await jwtVerify(input, key, {\r\n            algorithms: ['HS256'],\r\n        })\r\n        return payload\r\n    } catch {\r\n        return null\r\n    }\r\n}\r\n\r\nexport async function login() {\r\n    // Verify credentials and create session\r\n    // This function will be called from the server action or API route\r\n    // For now, we'll just handle the session creation part here\r\n}\r\n\r\nexport async function getSession() {\r\n    const cookieStore = await cookies()\r\n    const session = cookieStore.get('session')?.value\r\n    if (!session) return null\r\n    return await decrypt(session)\r\n}\r\n\r\nimport { NextRequest } from 'next/server'\r\n\r\nexport async function updateSession(request: NextRequest) {\r\n    const session = request.cookies.get('session')?.value\r\n    if (!session) return\r\n\r\n    // Refresh the session so it doesn't expire\r\n    const parsed = await decrypt(session) as any\r\n    parsed.expires = new Date(Date.now() + 24 * 60 * 60 * 1000)\r\n    // const res = new Response(null) // This needs to be handled in middleware\r\n    // In middleware we just return the response with the new cookie\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AAAA;AACA;;;AAEA,MAAM,YAAY,QAAQ,GAAG,CAAC,cAAc,IAAI;AAChD,MAAM,MAAM,IAAI,cAAc,MAAM,CAAC;AAE9B,eAAe,QAAQ,OAAmB;IAC7C,OAAO,MAAM,IAAI,kKAAO,CAAC,SACpB,kBAAkB,CAAC;QAAE,KAAK;IAAQ,GAClC,WAAW,GACX,iBAAiB,CAAC,OAClB,IAAI,CAAC;AACd;AAEO,eAAe,QAAQ,KAAa;IACvC,IAAI;QACA,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,IAAA,sKAAS,EAAC,OAAO,KAAK;YAC5C,YAAY;gBAAC;aAAQ;QACzB;QACA,OAAO;IACX,EAAE,OAAM;QACJ,OAAO;IACX;AACJ;AAEO,eAAe;AAClB,wCAAwC;AACxC,mEAAmE;AACnE,4DAA4D;AAChE;AAEO,eAAe;IAClB,MAAM,cAAc,MAAM,IAAA,4IAAO;IACjC,MAAM,UAAU,YAAY,GAAG,CAAC,YAAY;IAC5C,IAAI,CAAC,SAAS,OAAO;IACrB,OAAO,MAAM,QAAQ;AACzB;AAIO,eAAe,cAAc,OAAoB;IACpD,MAAM,UAAU,QAAQ,OAAO,CAAC,GAAG,CAAC,YAAY;IAChD,IAAI,CAAC,SAAS;IAEd,2CAA2C;IAC3C,MAAM,SAAS,MAAM,QAAQ;IAC7B,OAAO,OAAO,GAAG,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,KAAK,KAAK;AACtD,2EAA2E;AAC3E,gEAAgE;AACpE"}},
    {"offset": {"line": 128, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mouni/Desktop/marrakech/src/app/api/admin/customers/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server'\r\nimport prisma from '@/lib/prisma'\r\nimport { getSession } from '@/lib/auth'\r\n\r\nexport async function GET() {\r\n    const session = await getSession()\r\n    if (!session) {\r\n        return new NextResponse('Unauthorized', { status: 401 })\r\n    }\r\n\r\n    try {\r\n        const [users, subscribers] = await Promise.all([\r\n            prisma.user.findMany({\r\n                where: { role: 'USER' },\r\n                select: {\r\n                    id: true,\r\n                    name: true,\r\n                    email: true,\r\n                    role: true,\r\n                    createdAt: true,\r\n                },\r\n                orderBy: { createdAt: 'desc' }\r\n            }),\r\n            prisma.newsletterSubscriber.findMany({\r\n                where: { active: true },\r\n                orderBy: { createdAt: 'desc' }\r\n            })\r\n        ])\r\n\r\n        const usersWithStats = await Promise.all(users.map(async (user: { email: string; createdAt: Date; id: string; name: string | null; role: string }) => {\r\n            const bookingCount = await prisma.booking.count({\r\n                where: { email: user.email }\r\n            })\r\n            return {\r\n                ...user,\r\n                source: 'REGISTERED',\r\n                createdAt: user.createdAt,\r\n                _count: {\r\n                    bookings: bookingCount\r\n                }\r\n            }\r\n        }))\r\n\r\n        // Filter out subscribers who are already registered users\r\n        const registeredEmails = new Set(users.map((u: { email: string }) => u.email))\r\n\r\n        const subscribersList = subscribers\r\n            .filter((s: { email: string }) => !registeredEmails.has(s.email))\r\n            .map((s: { id: string; email: string; createdAt: Date }) => ({\r\n                id: s.id,\r\n                name: null,\r\n                email: s.email,\r\n                role: 'USER',\r\n                source: 'NEWSLETTER',\r\n                createdAt: s.createdAt,\r\n                _count: {\r\n                    bookings: 0\r\n                }\r\n            }))\r\n\r\n        const allCustomers = [...usersWithStats, ...subscribersList].sort(\r\n            (a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()\r\n        )\r\n\r\n        return NextResponse.json(allCustomers)\r\n    } catch (error) {\r\n        console.error('[CUSTOMERS_GET]', error)\r\n        return new NextResponse('Internal Error', { status: 500 })\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEO,eAAe;IAClB,MAAM,UAAU,MAAM,IAAA,kIAAU;IAChC,IAAI,CAAC,SAAS;QACV,OAAO,IAAI,gJAAY,CAAC,gBAAgB;YAAE,QAAQ;QAAI;IAC1D;IAEA,IAAI;QACA,MAAM,CAAC,OAAO,YAAY,GAAG,MAAM,QAAQ,GAAG,CAAC;YAC3C,iIAAM,CAAC,IAAI,CAAC,QAAQ,CAAC;gBACjB,OAAO;oBAAE,MAAM;gBAAO;gBACtB,QAAQ;oBACJ,IAAI;oBACJ,MAAM;oBACN,OAAO;oBACP,MAAM;oBACN,WAAW;gBACf;gBACA,SAAS;oBAAE,WAAW;gBAAO;YACjC;YACA,iIAAM,CAAC,oBAAoB,CAAC,QAAQ,CAAC;gBACjC,OAAO;oBAAE,QAAQ;gBAAK;gBACtB,SAAS;oBAAE,WAAW;gBAAO;YACjC;SACH;QAED,MAAM,iBAAiB,MAAM,QAAQ,GAAG,CAAC,MAAM,GAAG,CAAC,OAAO;YACtD,MAAM,eAAe,MAAM,iIAAM,CAAC,OAAO,CAAC,KAAK,CAAC;gBAC5C,OAAO;oBAAE,OAAO,KAAK,KAAK;gBAAC;YAC/B;YACA,OAAO;gBACH,GAAG,IAAI;gBACP,QAAQ;gBACR,WAAW,KAAK,SAAS;gBACzB,QAAQ;oBACJ,UAAU;gBACd;YACJ;QACJ;QAEA,0DAA0D;QAC1D,MAAM,mBAAmB,IAAI,IAAI,MAAM,GAAG,CAAC,CAAC,IAAyB,EAAE,KAAK;QAE5E,MAAM,kBAAkB,YACnB,MAAM,CAAC,CAAC,IAAyB,CAAC,iBAAiB,GAAG,CAAC,EAAE,KAAK,GAC9D,GAAG,CAAC,CAAC,IAAsD,CAAC;gBACzD,IAAI,EAAE,EAAE;gBACR,MAAM;gBACN,OAAO,EAAE,KAAK;gBACd,MAAM;gBACN,QAAQ;gBACR,WAAW,EAAE,SAAS;gBACtB,QAAQ;oBACJ,UAAU;gBACd;YACJ,CAAC;QAEL,MAAM,eAAe;eAAI;eAAmB;SAAgB,CAAC,IAAI,CAC7D,CAAC,GAAG,IAAM,IAAI,KAAK,EAAE,SAAS,EAAE,OAAO,KAAK,IAAI,KAAK,EAAE,SAAS,EAAE,OAAO;QAG7E,OAAO,gJAAY,CAAC,IAAI,CAAC;IAC7B,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,mBAAmB;QACjC,OAAO,IAAI,gJAAY,CAAC,kBAAkB;YAAE,QAAQ;QAAI;IAC5D;AACJ"}}]
}