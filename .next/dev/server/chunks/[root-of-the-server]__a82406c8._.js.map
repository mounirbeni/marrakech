{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mouni/Desktop/marrakech/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\r\n\r\nconst prismaClientSingleton = () => {\r\n    return new PrismaClient()\r\n}\r\n\r\ndeclare global {\r\n    var prisma: undefined | ReturnType<typeof prismaClientSingleton>\r\n}\r\n\r\nconst prisma = globalThis.prisma ?? prismaClientSingleton()\r\n\r\nexport default prisma\r\n\r\nif (process.env.NODE_ENV !== 'production') globalThis.prisma = prisma\r\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,wBAAwB;IAC1B,OAAO,IAAI,6IAAY;AAC3B;AAMA,MAAM,SAAS,WAAW,MAAM,IAAI;uCAErB;AAEf,wCAA2C,WAAW,MAAM,GAAG"}},
    {"offset": {"line": 68, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mouni/Desktop/marrakech/src/lib/trip-logic.ts"],"sourcesContent":["import { Booking } from '@prisma/client';\r\n\r\nexport type TripState = 'NO_TRIP' | 'UPCOMING' | 'ONGOING' | 'COMPLETED';\r\n\r\nexport function determineTripState(bookings: Booking[]): TripState {\r\n    if (!bookings || bookings.length === 0) {\r\n        return 'NO_TRIP';\r\n    }\r\n\r\n    const now = new Date();\r\n\r\n    // Sort bookings by date, most recent first\r\n    const sortedBookings = [...bookings].sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());\r\n\r\n    // Find the most relevant booking\r\n    // Logic: \r\n    // 1. Is there a booking happening right now? (Ongoing)\r\n    // 2. Is there a booking in the future? (Upcoming)\r\n    // 3. Was there a booking recently? (Completed)\r\n\r\n    // This is a simplified logic. In reality, a \"Trip\" might define a range of dates containing multiple bookings.\r\n    // For now, we look at individual bookings.\r\n\r\n    const VALID_STATUSES = ['CONFIRMED', 'UNPROCESSED', 'PENDING'];\r\n    const upcomingBookings = sortedBookings.filter(b => new Date(b.date) > now && VALID_STATUSES.includes(b.status));\r\n    const pastBookings = sortedBookings.filter(b => new Date(b.date) <= now && VALID_STATUSES.includes(b.status)); // And not cancelled\r\n\r\n    if (upcomingBookings.length > 0) {\r\n        // Check if the closest upcoming booking is actually \"ongoing\" (e.g. started 1 hour ago but lasts 4 hours)\r\n        // For now, assuming \"Upcoming\" if start date is in future.\r\n\r\n        // But wait, if we have a booking TODAY, it might be ongoing.\r\n        // Let's refine.\r\n\r\n        const nextBooking = upcomingBookings[upcomingBookings.length - 1]; // closest future booking\r\n        const timeDiff = new Date(nextBooking.date).getTime() - now.getTime();\r\n        const hoursDiff = timeDiff / (1000 * 60 * 60);\r\n\r\n        if (hoursDiff < 24 && hoursDiff > -24) {\r\n            // If it's within 24 hours? \r\n            // Actually, \"Ongoing\" usually means the user is physically there.\r\n            // Let's assume distinct states for now.\r\n            return 'UPCOMING';\r\n        }\r\n        return 'UPCOMING';\r\n    }\r\n\r\n    // If no upcoming bookings, check if we have any active/ongoing ones.\r\n    // Since we filtered \"upcoming\" as > now, \"past\" is <= now.\r\n    // If a booking started 1 hour ago, it's in \"pastBookings\" but technically \"Ongoing\" if it has duration.\r\n    // We need duration.\r\n\r\n    // For this MVP logic without duration parsing:\r\n    // If the most recent past booking was within 24 hours, call it \"ONGOING\" or \"COMPLETED\" depending on logic.\r\n    // Let's assume if it started < 12 hours ago, it's ONGOING.\r\n\r\n    if (pastBookings.length > 0) {\r\n        const lastBooking = pastBookings[0];\r\n        const timeSinceStart = now.getTime() - new Date(lastBooking.date).getTime();\r\n        const hoursSinceStart = timeSinceStart / (1000 * 60 * 60);\r\n\r\n        if (hoursSinceStart < 12) {\r\n            return 'ONGOING';\r\n        }\r\n\r\n        return 'COMPLETED';\r\n    }\r\n\r\n    return 'NO_TRIP';\r\n}\r\n"],"names":[],"mappings":";;;;AAIO,SAAS,mBAAmB,QAAmB;IAClD,IAAI,CAAC,YAAY,SAAS,MAAM,KAAK,GAAG;QACpC,OAAO;IACX;IAEA,MAAM,MAAM,IAAI;IAEhB,2CAA2C;IAC3C,MAAM,iBAAiB;WAAI;KAAS,CAAC,IAAI,CAAC,CAAC,GAAG,IAAM,IAAI,KAAK,EAAE,IAAI,EAAE,OAAO,KAAK,IAAI,KAAK,EAAE,IAAI,EAAE,OAAO;IAEzG,iCAAiC;IACjC,UAAU;IACV,uDAAuD;IACvD,kDAAkD;IAClD,+CAA+C;IAE/C,+GAA+G;IAC/G,2CAA2C;IAE3C,MAAM,iBAAiB;QAAC;QAAa;QAAe;KAAU;IAC9D,MAAM,mBAAmB,eAAe,MAAM,CAAC,CAAA,IAAK,IAAI,KAAK,EAAE,IAAI,IAAI,OAAO,eAAe,QAAQ,CAAC,EAAE,MAAM;IAC9G,MAAM,eAAe,eAAe,MAAM,CAAC,CAAA,IAAK,IAAI,KAAK,EAAE,IAAI,KAAK,OAAO,eAAe,QAAQ,CAAC,EAAE,MAAM,IAAI,oBAAoB;IAEnI,IAAI,iBAAiB,MAAM,GAAG,GAAG;QAC7B,0GAA0G;QAC1G,2DAA2D;QAE3D,6DAA6D;QAC7D,gBAAgB;QAEhB,MAAM,cAAc,gBAAgB,CAAC,iBAAiB,MAAM,GAAG,EAAE,EAAE,yBAAyB;QAC5F,MAAM,WAAW,IAAI,KAAK,YAAY,IAAI,EAAE,OAAO,KAAK,IAAI,OAAO;QACnE,MAAM,YAAY,WAAW,CAAC,OAAO,KAAK,EAAE;QAE5C,IAAI,YAAY,MAAM,YAAY,CAAC,IAAI;YACnC,4BAA4B;YAC5B,kEAAkE;YAClE,wCAAwC;YACxC,OAAO;QACX;QACA,OAAO;IACX;IAEA,qEAAqE;IACrE,2DAA2D;IAC3D,wGAAwG;IACxG,oBAAoB;IAEpB,+CAA+C;IAC/C,4GAA4G;IAC5G,2DAA2D;IAE3D,IAAI,aAAa,MAAM,GAAG,GAAG;QACzB,MAAM,cAAc,YAAY,CAAC,EAAE;QACnC,MAAM,iBAAiB,IAAI,OAAO,KAAK,IAAI,KAAK,YAAY,IAAI,EAAE,OAAO;QACzE,MAAM,kBAAkB,iBAAiB,CAAC,OAAO,KAAK,EAAE;QAExD,IAAI,kBAAkB,IAAI;YACtB,OAAO;QACX;QAEA,OAAO;IACX;IAEA,OAAO;AACX"}},
    {"offset": {"line": 139, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mouni/Desktop/marrakech/src/lib/auth.ts"],"sourcesContent":["\r\nimport { SignJWT, jwtVerify } from 'jose';\r\nimport bcrypt from 'bcryptjs';\r\nimport { cookies } from 'next/headers';\r\n\r\nconst JWT_SECRET = new TextEncoder().encode(\r\n    process.env.JWT_SECRET || 'default-secret-key-change-this'\r\n);\r\n\r\nexport async function hashPassword(password: string): Promise<string> {\r\n    return await bcrypt.hash(password, 10);\r\n}\r\n\r\nexport async function comparePassword(plain: string, hashed: string): Promise<boolean> {\r\n    return await bcrypt.compare(plain, hashed);\r\n}\r\n\r\nexport interface UserPayload {\r\n    id: string;\r\n    email: string;\r\n    role: string;\r\n    name?: string | null;\r\n    [key: string]: unknown;\r\n}\r\n\r\nexport async function signJWT(payload: UserPayload): Promise<string> {\r\n    return new SignJWT(payload)\r\n        .setProtectedHeader({ alg: 'HS256' })\r\n        .setIssuedAt()\r\n        .setExpirationTime('1h')\r\n        .sign(JWT_SECRET);\r\n}\r\n\r\nexport async function verifyJWT(token: string): Promise<UserPayload | null> {\r\n    try {\r\n        const { payload } = await jwtVerify(token, JWT_SECRET);\r\n        return payload as UserPayload;\r\n    } catch {\r\n        return null;\r\n    }\r\n}\r\n\r\nexport async function getSession() {\r\n    const cookieStore = await cookies();\r\n    const token = cookieStore.get('auth_token')?.value;\r\n\r\n    if (!token) return null;\r\n\r\n    return await verifyJWT(token);\r\n}\r\n\r\nexport async function loginUser(payload: UserPayload) {\r\n    const token = await signJWT(payload);\r\n    const cookieStore = await cookies();\r\n\r\n    // Set cookie\r\n    cookieStore.set('auth_token', token, {\r\n        httpOnly: true,\r\n        secure: process.env.NODE_ENV === 'production',\r\n        maxAge: 60 * 60, // 1 hour\r\n        path: '/',\r\n    });\r\n}\r\n\r\nexport async function logoutUser() {\r\n    const cookieStore = await cookies();\r\n    cookieStore.delete('auth_token');\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AACA;AAAA;AACA;AACA;;;;AAEA,MAAM,aAAa,IAAI,cAAc,MAAM,CACvC,QAAQ,GAAG,CAAC,UAAU,IAAI;AAGvB,eAAe,aAAa,QAAgB;IAC/C,OAAO,MAAM,8IAAM,CAAC,IAAI,CAAC,UAAU;AACvC;AAEO,eAAe,gBAAgB,KAAa,EAAE,MAAc;IAC/D,OAAO,MAAM,8IAAM,CAAC,OAAO,CAAC,OAAO;AACvC;AAUO,eAAe,QAAQ,OAAoB;IAC9C,OAAO,IAAI,kKAAO,CAAC,SACd,kBAAkB,CAAC;QAAE,KAAK;IAAQ,GAClC,WAAW,GACX,iBAAiB,CAAC,MAClB,IAAI,CAAC;AACd;AAEO,eAAe,UAAU,KAAa;IACzC,IAAI;QACA,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,IAAA,sKAAS,EAAC,OAAO;QAC3C,OAAO;IACX,EAAE,OAAM;QACJ,OAAO;IACX;AACJ;AAEO,eAAe;IAClB,MAAM,cAAc,MAAM,IAAA,4IAAO;IACjC,MAAM,QAAQ,YAAY,GAAG,CAAC,eAAe;IAE7C,IAAI,CAAC,OAAO,OAAO;IAEnB,OAAO,MAAM,UAAU;AAC3B;AAEO,eAAe,UAAU,OAAoB;IAChD,MAAM,QAAQ,MAAM,QAAQ;IAC5B,MAAM,cAAc,MAAM,IAAA,4IAAO;IAEjC,aAAa;IACb,YAAY,GAAG,CAAC,cAAc,OAAO;QACjC,UAAU;QACV,QAAQ,oDAAyB;QACjC,QAAQ,KAAK;QACb,MAAM;IACV;AACJ;AAEO,eAAe;IAClB,MAAM,cAAc,MAAM,IAAA,4IAAO;IACjC,YAAY,MAAM,CAAC;AACvB"}},
    {"offset": {"line": 207, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/mouni/Desktop/marrakech/src/app/api/dashboard/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\r\nimport prisma from '@/lib/prisma';\r\nimport { determineTripState } from '@/lib/trip-logic';\r\nimport { getSession } from '@/lib/auth';\r\n\r\nexport async function GET(request: Request) {\r\n    try {\r\n        const session = await getSession();\r\n        if (!session) {\r\n            return new NextResponse('Unauthorized', { status: 401 });\r\n        }\r\n\r\n        const userId = session.id;\r\n\r\n        const bookings = await prisma.booking.findMany({\r\n            where: {\r\n                OR: [\r\n                    { userId: userId },\r\n                    { email: session.email }\r\n                ]\r\n            },\r\n            orderBy: { date: 'asc' }\r\n        });\r\n\r\n        const state = determineTripState(bookings);\r\n\r\n        // Calculate Stats\r\n        const totalBookings = bookings.length;\r\n\r\n        // Loyalty Points: 100 points per completed booking, 50 per pending? Let's say 10 points * total price/10 (Euro spent logic) or simple count. \r\n        // Simple logic: 200 points per booking.\r\n        const loyaltyPoints = bookings.length * 200;\r\n\r\n        // Next Trip Logic\r\n        const now = new Date();\r\n        const futureBookings = bookings.filter(b => new Date(b.date) > now && b.status !== 'CANCELLED');\r\n        const nextTrip = futureBookings.length > 0 ? futureBookings[0] : null;\r\n\r\n        let nextTripJson = null;\r\n        if (nextTrip) {\r\n            const diffTime = Math.abs(new Date(nextTrip.date).getTime() - now.getTime());\r\n            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));\r\n            nextTripJson = {\r\n                days: diffDays,\r\n                title: nextTrip.activityTitle\r\n            };\r\n        }\r\n\r\n        return NextResponse.json({\r\n            state,\r\n            tripState: state, // redundancy for frontend safety\r\n            bookings,\r\n            stats: {\r\n                totalBookings,\r\n                loyaltyPoints,\r\n                nextTrip: nextTripJson\r\n            },\r\n            user: {\r\n                name: session.name || 'Traveler'\r\n            }\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error('Dashboard API Error:', error);\r\n        return new NextResponse('Internal Server Error', { status: 500 });\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEO,eAAe,IAAI,OAAgB;IACtC,IAAI;QACA,MAAM,UAAU,MAAM,IAAA,kIAAU;QAChC,IAAI,CAAC,SAAS;YACV,OAAO,IAAI,gJAAY,CAAC,gBAAgB;gBAAE,QAAQ;YAAI;QAC1D;QAEA,MAAM,SAAS,QAAQ,EAAE;QAEzB,MAAM,WAAW,MAAM,iIAAM,CAAC,OAAO,CAAC,QAAQ,CAAC;YAC3C,OAAO;gBACH,IAAI;oBACA;wBAAE,QAAQ;oBAAO;oBACjB;wBAAE,OAAO,QAAQ,KAAK;oBAAC;iBAC1B;YACL;YACA,SAAS;gBAAE,MAAM;YAAM;QAC3B;QAEA,MAAM,QAAQ,IAAA,mJAAkB,EAAC;QAEjC,kBAAkB;QAClB,MAAM,gBAAgB,SAAS,MAAM;QAErC,8IAA8I;QAC9I,wCAAwC;QACxC,MAAM,gBAAgB,SAAS,MAAM,GAAG;QAExC,kBAAkB;QAClB,MAAM,MAAM,IAAI;QAChB,MAAM,iBAAiB,SAAS,MAAM,CAAC,CAAA,IAAK,IAAI,KAAK,EAAE,IAAI,IAAI,OAAO,EAAE,MAAM,KAAK;QACnF,MAAM,WAAW,eAAe,MAAM,GAAG,IAAI,cAAc,CAAC,EAAE,GAAG;QAEjE,IAAI,eAAe;QACnB,IAAI,UAAU;YACV,MAAM,WAAW,KAAK,GAAG,CAAC,IAAI,KAAK,SAAS,IAAI,EAAE,OAAO,KAAK,IAAI,OAAO;YACzE,MAAM,WAAW,KAAK,IAAI,CAAC,WAAW,CAAC,OAAO,KAAK,KAAK,EAAE;YAC1D,eAAe;gBACX,MAAM;gBACN,OAAO,SAAS,aAAa;YACjC;QACJ;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YACrB;YACA,WAAW;YACX;YACA,OAAO;gBACH;gBACA;gBACA,UAAU;YACd;YACA,MAAM;gBACF,MAAM,QAAQ,IAAI,IAAI;YAC1B;QACJ;IAEJ,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,wBAAwB;QACtC,OAAO,IAAI,gJAAY,CAAC,yBAAyB;YAAE,QAAQ;QAAI;IACnE;AACJ"}}]
}